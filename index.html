<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/shailon/shailon.github.io@main/estilosss.css">
		
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/shailon/shailon.github.io@main/all.css">
		<title>Los mejores jugadores de apuestas en vivo</title>
    		
        
	</head>
<body>
		<!-- Header -->
		<main>			
			<div class="content-all">
				<header></header>
				<label>
					nomovies
				</label>

				<div class="btn">
					
				</div>
			</div>
		</main>

		<div class="container">
<meta name="referrer" content="never" />

			<div class="item">
			
			</div>

		</div>


	</body>

    <div id="110860-44"><script src="//ads.themoneytizer.com/s/gen.js?type=44">
    </script>
    <script src="//ads.themoneytizer.com/s/requestform.js?siteId=110860&formatId=44">
    </script>
    </div>
		<script async src="https://js.wpadmngr.com/static/adManager.js" data-admpid="79765">
    </script>
    
    
    
    
<!-- Quantcast Choice. Consent Manager Tag v2.0 (for TCF 2.0) -->
<script type="text/javascript" async=true>
(function() {
  var host = 'www.themoneytizer.com';
  var element = document.createElement('script');
  var firstScript = document.getElementsByTagName('script')[0];
  var url = 'https://cmp.quantcast.com'
    .concat('/choice/', '6Fv0cGNfc_bw8', '/', host, '/choice.js');
  var uspTries = 0;
  var uspTriesLimit = 3;
  element.async = true;
  element.type = 'text/javascript';
  element.src = url;

  firstScript.parentNode.insertBefore(element, firstScript);

  function makeStub() {
    var TCF_LOCATOR_NAME = '__tcfapiLocator';
    var queue = [];
    var win = window;
    var cmpFrame;

    function addFrame() {
      var doc = win.document;
      var otherCMP = !!(win.frames[TCF_LOCATOR_NAME]);

      if (!otherCMP) {
        if (doc.body) {
          var iframe = doc.createElement('iframe');

          iframe.style.cssText = 'display:none';
          iframe.name = TCF_LOCATOR_NAME;
          doc.body.appendChild(iframe);
        } else {
          setTimeout(addFrame, 5);
        }
      }
      return !otherCMP;
    }

    function tcfAPIHandler() {
      var gdprApplies;
      var args = arguments;

      if (!args.length) {
        return queue;
      } else if (args[0] === 'setGdprApplies') {
        if (
          args.length > 3 &&
          args[2] === 2 &&
          typeof args[3] === 'boolean'
        ) {
          gdprApplies = args[3];
          if (typeof args[2] === 'function') {
            args[2]('set', true);
          }
        }
      } else if (args[0] === 'ping') {
        var retr = {
          gdprApplies: gdprApplies,
          cmpLoaded: false,
          cmpStatus: 'stub'
        };

        if (typeof args[2] === 'function') {
          args[2](retr);
        }
      } else {
        if(args[0] === 'init' && typeof args[3] === 'object') {
          args[3] = { ...args[3], tag_version: 'V2' };
        }
        queue.push(args);
      }
    }

    function postMessageEventHandler(event) {
      var msgIsString = typeof event.data === 'string';
      var json = {};

      try {
        if (msgIsString) {
          json = JSON.parse(event.data);
        } else {
          json = event.data;
        }
      } catch (ignore) {}

      var payload = json.__tcfapiCall;

      if (payload) {
        window.__tcfapi(
          payload.command,
          payload.version,
          function(retValue, success) {
            var returnMsg = {
              __tcfapiReturn: {
                returnValue: retValue,
                success: success,
                callId: payload.callId
              }
            };
            if (msgIsString) {
              returnMsg = JSON.stringify(returnMsg);
            }
            if (event && event.source && event.source.postMessage) {
              event.source.postMessage(returnMsg, '*');
            }
          },
          payload.parameter
        );
      }
    }

    while (win) {
      try {
        if (win.frames[TCF_LOCATOR_NAME]) {
          cmpFrame = win;
          break;
        }
      } catch (ignore) {}

      if (win === window.top) {
        break;
      }
      win = win.parent;
    }
    if (!cmpFrame) {
      addFrame();
      win.__tcfapi = tcfAPIHandler;
      win.addEventListener('message', postMessageEventHandler, false);
    }
  };

  makeStub();

  var uspStubFunction = function() {
    var arg = arguments;
    if (typeof window.__uspapi !== uspStubFunction) {
      setTimeout(function() {
        if (typeof window.__uspapi !== 'undefined') {
          window.__uspapi.apply(window.__uspapi, arg);
        }
      }, 500);
    }
  };

  var checkIfUspIsReady = function() {
    uspTries++;
    if (window.__uspapi === uspStubFunction && uspTries < uspTriesLimit) {
      console.warn('USP is not accessible');
    } else {
      clearInterval(uspInterval);
    }
  };

  if (typeof window.__uspapi === 'undefined') {
    window.__uspapi = uspStubFunction;
    var uspInterval = setInterval(checkIfUspIsReady, 6000);
  }
})();
</script>
<!-- End Quantcast Choice. Consent Manager Tag v2.0 (for TCF 2.0) -->


    <label>
					para publicar contactar con chireaqp@gmail.com
	    
	    
	    
	    
	    vendo cuenta Honkai: Star Rail con himeko a 50 dolares mensaje a chireaqp@gmail.com
				</label>
    
    <img src="https://embed-ssl.wistia.com/deliveries/167b00461ab695ef3fbc2aeae54c4117.bin?disposition=attachment&filename=ewefewfwefwef.jpg" alt="Trulli" width="500" height="333">
    
    <div class="container">

  
    


<!-- DRAGABLE 3 -->
<!-- Draggable DIV -->
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<div id="mydiv1"  class="js_zoom_and_pan1">
  <div id="mydivheader1">Click Aqui para mover</div>
  <script>
  
  
  
  (function() {
  function touchHandler(e) {
    var touches = e.changedTouches;
    var first = touches[0];
    var type = "";

    switch(e.type) {
      case "touchstart":
        type = "mousedown";
        break;
      case "touchmove":
        type="mousemove";
        break;
      case "touchend":
        type="mouseup";
        break;
      default:
        return;
    }

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);

    first.target.dispatchEvent(simulatedEvent);
    e.preventDefault();
  }

  function init() {
    document.addEventListener("touchstart", touchHandler, true);
    document.addEventListener("touchmove", touchHandler, true);
    document.addEventListener("touchend", touchHandler, true);
    document.addEventListener("touchcancel", touchHandler, true);
  }

  init();
})();


(function($) {
    $.fn.drags = function(opt) {

        opt = $.extend({handle:"",cursor:"move"}, opt);

        if(opt.handle === "") {
            var $el = this;
        } else {
            var $el = this.find(opt.handle);
        }

        return $el.css('cursor', opt.cursor).on("mousedown", function(e) {
            if(opt.handle === "") {
                var $drag = $(this).addClass('draggable');
            } else {
                var $drag = $(this).addClass('active-handle').parent().addClass('draggable');
            }
            var z_idx = $drag.css('z-index'),
                drg_h = $drag.outerHeight(),
                drg_w = $drag.outerWidth(),
                pos_y = $drag.offset().top + drg_h - e.pageY,
                pos_x = $drag.offset().left + drg_w - e.pageX;
            $drag.css('z-index', 1000).parents().on("mousemove", function(e) {
                $('.draggable').offset({
                    top:e.pageY + pos_y - drg_h,
                    left:e.pageX + pos_x - drg_w
                }).on("mouseup", function() {
                    $(this).removeClass('draggable').css('z-index', z_idx);
                });
            });
            e.preventDefault(); // disable selection
        }).on("mouseup", function() {
            if(opt.handle === "") {
                $(this).removeClass('draggable');
            } else {
                $(this).removeClass('active-handle').parent().removeClass('draggable');
            }
        });

    }
})(jQuery);

$('#mydiv1111').drags();
  
  
  
  
  
  
  
  
 



</script>
<style>
#mydiv1 {
  padding: 0px;
		margin: 0px;
		position: fixed;
  top: 10px;
		left: 0px;
		bottom:0px;
		width: 120px;
    height: 230px;
    text-align: center;
    z-index: 0px;
    font-size: 5px;
}

#mydivheader1 {
  border-radius: 15px;
 padding: 10px;
  cursor: grab;
  
  background-color: #2196F3;
  color: #fff;
  
}
</style>
 <!-- BUSCADOR 3 -->
  <!-- Trigger/Open The Modal -->
	<button id="myBtn1" class="button button1">super</button>
<!-- The Modal -->
		<div id="myModal1" class="modal1">
<!-- Modal content -->
		<div class="modal1-content">
		<div class="modal1-header">
			<span class="close1">X</span>
	</div>
  <div class="modal1-body">
	<script>
  // Get the modal
var modal1 = document.getElementById('myModal1');
// Get the modal
var modal1 = document.getElementById('myModal1');
// Get the button that opens the modal
var btn1 = document.getElementById("myBtn1");
// Get the <span> element that closes the modal
var span1 = document.getElementsByClassName("close1")[0];
// When the user clicks on the button, open the modal
btn1.onclick = function() {
    modal1.style.display = "block";
	modal1.style.display = "block";
}
// When the user clicks on <span> (x), close the modal
span1.onclick = function() {
    modal1.style.display = "none";
}
// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal1) {
        modal1.style.display = "none";
    }
}
</script>
<body>
 <style>
      #twitch-embed {
        
        margin-right: 20px;
        top:300px;
       border: 0px solid #888;
        width: 180px;
        height: 240px;
        
      }
    </style>

<iframe class="item-video" allowfullscreen="" frameborder="0" height="100%" id="iframe2" onload="$('.iframe-loading').css('background-image');" sandbox="allow-same-origin allow-scripts"
				scrolling="no" src="https://ok.ru/videoembed/5274764511860" style="background-color: black; border-color: #fff; border-radius: 10px; border-style: solid; border-width: 2px;;" width="100%"></iframe>
    </body>
<!-- trovo 3 -->
<body>
<div>
</div>
</body>
</div>
</div>
</div>
<style type="text/css">
body {
	font-family: Arial, Helvetica, sans-serif;
}
t /* The Modal (background) */
.modal1 {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1px; /* Sit on top */
    left: 0px;
    top: 300px;
     margin: 0px; /* 15% from the top and centered */
    border: 0px solid #888;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    
}
/* Modal Content/Box contenido de tiwtch  */
.modal1-content {
	position: fixed;
    background-color: #fefefe;
    margin: 0px; /* 15% from the top and centered */
    padding: 0;
   border: 0px solid #888;
	border-radius: 15px;
    width: 120px; /* Could be more or less, depending on screen size */
	box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 0.4s;
    animation-name: animatebottom;
    animation-duration: 0.4s
}

/* Add Animation */
@-webkit-keyframes animatetop {
    from {top:-300px; opacity:0} 
    to {top:0; opacity:1}
}
@keyframes animatetop {
    from {top:-300px; opacity:0}
    to {top:0; opacity:1}
}
/* The Close Button */
.close1 {
    color: #666;
    float: right;
    font-size: 9px;
    font-weight: bold;
}
.close1:hover, .close1:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}
/* Modal Header */
.modal1-header {
    padding: 2px 16px;
    background-color: #f0f0f0;
	font-size: 22px;
	text-align: center;
    color: black;
}
/* Modal Body */
.modal1-body {padding: 2px 16px;}
.button1 {
top: 300px;
width: 100px;
font-size: 10px;
margin: 0px; /* 15% from the top and centered */
 }
</style>
  </div>
<!-- BUSCADOR 3 -->
      
		

<!--

TODO: lots of code cleanup, closure, scoping, options, config, etc.
      But it is a working prototype so far.

Interface:
- DoubleClick to reset element to original zoom and position.
- Mousewheel to zoom.
- Click and drag to pan element.

Works: 
- zooming in/out by using mousewheel
- panning image so mouse cursor stays focused on the same spot while zooming,
  (using css transform: translate(x%, y%) )
- pan image by dragging, using same system as above so we can both zoom and pan without problems.

See js panel for more details.

TODO: check support for different browser clients.


-->

<a href="js_zoom_and_pan1" class="MagicZoom" data-options="zoomMode: off"><img src=""></a>

<style>
html, body{
	background: #000;
	color: #fff;
	margin: 0;
	padding: 0;
}
container {
	position: absolute;
	top: 10px;
	left: 10px;
	overflow: hidden;
	width: 95%;
	height: 95%;
	background: rgba(255, 0, 255, 0.1);
	border: 1px solid rgba(255, 0, 255, 0.2);
}
.js_zoom_and_pan1 {
	background: rgba(255, 255, 0, 0.1);
	border: 1px solid rgba(255, 255, 0, 0.2);
  
}
.js_zoom_and_pan1:hover {
    
    zoom: 2.3;
}

</style>

<script>


// https://jsfiddle.net/ElMoonLite/fog2vach/

// TODO: lots of code cleanup, closure, scoping, etc.
//
// REQUIREMENTS:
// Can basicly zoom and pan any element, 
// as long as nothing else is adjusting it's css properties for zoom and/or transform.
// Works best if inside an overflow: hidden element. 
// Can get weird behaviour if inside a scrollable element (or even full document scroll).
//
// NOTES, references, etc.:
// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
// https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
// deltaY > 0 = mousewheel down
// To make event.preventDefault() work on wheel event:
// https://stackoverflow.com/questions/44406297/mark-event-as-explicitly-not-passive


// https://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery
function ready(callback) {
	if (document.readyState!='loading') {
		// in case the document is already rendered
		callback();
	} else if (document.addEventListener) {
		// modern browsers
		document.addEventListener('DOMContentLoaded', callback);
	} else {
		// IE <= 8
		document.attachEvent('onreadystatechange', function(){
			if (document.readyState=='complete') {
				callback();
			}
		});
	}
}

ready(function() {
    init();
});

function init() {
	// wheel event for zooming:
	// NB: { passive: false } needed so we can do event.preventDefault() on mousewheel event (to prevent scrolling and zooming at the same time).
	document.body.addEventListener('wheel', function(event) {
		handleWheel(event);
	}, { passive: false } );

	// events below are for panning:
	document.body.addEventListener('dragstart', function(event){
		handleDragStart(event);
	});
	document.body.addEventListener('dragend', function(event){
		stopDrag();
	});
	document.body.addEventListener('drag', function(event){
		handleDrag(event);
	});
//	// This prevents dragging the entire element out of view if it is inside an overflow: hidden container, 
//	// (in which case you can't drag it back into view again).
//	// Except that it does not seem to work... mouseout never fires while dragging?
//	document.body.addEventListener('mouseout', function(event){
//		console.log('mouseout', event);
//		stopDrag();
//	});
	document.body.addEventListener('dblclick', function(event){
		handleDblClick(event);
	});
}

function ElementIsZoomPanTarget(el) {
	//	if (el.tagName !== 'IMG') { return false; }
	return el && el.classList && el.classList.contains && el.classList.contains('js_zoom_and_pan1');
}

function handleDblClick(event) {
	var el = event.target;
	if (ElementIsZoomPanTarget(el) ) {
		event.preventDefault();
		clearSelection();
		resetElement(el);
	}
	// if element has a direct child also reset it.
	// this allows easy resetting of element just outside element in parent element, 
	// which is handy in case it moves out of frame or just for convenience.
	if (el.childNodes && el.childNodes.length) {
		for (var i=0; i<el.childNodes.length; i++) {
			var el2 = el.childNodes[i];
			if (ElementIsZoomPanTarget(el2) ) {
				event.preventDefault();
				clearSelection();
				resetElement(el2);
			}
		}
	}
}
function resetElement(el) {
	stopDrag();
	el.style.zoom = 1;
	el.scale = 1;
	el.style.transform = 'translate(0%, 0%)';
	el.current_translate_x = 0;
	el.current_translate_y = 0;
}
function clearSelection()
{
	if (window.getSelection) {
		window.getSelection().removeAllRanges();
	} else if (document.selection) {
		document.selection.empty();
	}
}



function handleWheel(event) {
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	event.preventDefault();
	if(isDragging()) {
		// prevent zooming while dragging/panning or things get really complicated.
		return;
	}
	zoomElement(el, event, true);
}

function zoomElement(el, event, zoomatcursor) {
	// Also autoscroll so mouse pointer is on the same relative position after zooming.
	// - using parent element scrolling container?
	// - using translateXY ? transform: translate(100px, 200px);
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-box
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
	// DONE! works :), but:
	//
	// TODO: sometimes after a while weird things happen when zooming.
	// I think it has to do with zooming out, the element becoming smaller and then the max scrollwidth/height gets smaller and the parent element also starts scrolling?

	var scale = 1;
	if (el.scale) {
		scale = el.scale;
	}

	var scale_delta;
	if (event.deltaY < 0) {
		scale_delta = 1.25;
	} else {
		scale_delta = 1 / 1.25; // 0.8
	}
	scale *= scale_delta;


	// attempt at zooming in/out on cursor (scrolling so mouse keeps in same original spot)
	var md = {}; // mousedata
	if (zoomatcursor) {
		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX
		// The offsetX read-only property of the MouseEvent interface provides the offset in the X coordinate of the mouse pointer between that event and the padding edge of the target node.
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * scale;
		md.el_width  = md.el_width_original  * scale;
		md.el_mouse_x = event.offsetX;
		md.el_mouse_y = event.offsetY;
		md.el_mouse_relative_x = md.el_mouse_x / md.el_width;
		md.el_mouse_relative_y = md.el_mouse_y / md.el_height;
	}


	if (scale > 1 - 0.01 && scale < 1 + 0.01) {
		// when zooming in and out a few times due to floating point issues you might not end up at 1 again, fix this:
		scale = 1;
	}
//	scale = Math.min(Math.max(0.125, scale), 4);

	// store new current scale on element for next event:
	el.scale = scale;

	// NB: using transform: scale() produces odd behaviour (or does not work at all) with scale < 1. but zoom seems to work just fine.
//	el.style.transform = 'scale(' + scale + ')';
	el.style.zoom = scale;

	if (zoomatcursor) {
		var current_translate_x = 0;
		var current_translate_y = 0;
		var new_translate_x = 0, new_translate_y = 0;
		if (el.current_translate_x) { current_translate_x = el.current_translate_x; }
		if (el.current_translate_y) { current_translate_y = el.current_translate_y; }

//		// with scale_delta = 1.25 or 1/1.25:
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.

//		if (scale_delta > 1) {
//			new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / scale_delta;
//			new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / scale_delta;
//		} else {
//			new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x / scale_delta;
//			new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y / scale_delta;
//		}

		// The above combined:
		new_translate_x = (md.el_mouse_relative_x) * (1.0 - scale_delta) + current_translate_x / scale_delta;
		new_translate_y = (md.el_mouse_relative_y) * (1.0 - scale_delta) + current_translate_y / scale_delta;

		el.current_translate_x = new_translate_x;
		el.current_translate_y = new_translate_y;

//		new_translate_x = (new_translate_x) + 'px';
//		new_translate_y = (new_translate_y) + 'px';
		new_translate_x = (new_translate_x * 100.0) + '%';
		new_translate_y = (new_translate_y * 100.0) + '%';
		el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
	}

}

// additional: Panning: on mouse down drag; also translate target:
// tricky as we get mouse offset in px, but need to adjust translate in % .
var drag = {};
function isDragging() {
	return !!drag.target;
}
function stopDrag() {
	drag.target = null;
}
function handleDragStart(event) {
	if (isDragging()) {
		return;
	}
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	drag.target = el;
	drag.mousedown = {};
	drag.mousedown.clientX = event.clientX;
	drag.mousedown.clientY = event.clientY;
	drag.mousedown.translate_x = el.current_translate_x || 0;
	drag.mousedown.translate_y = el.current_translate_y || 0;
	drag.scale = el.scale || 1;
}
function handleDrag(event){
	var el = event.target;
	if (!drag.target || el !== drag.target) {
		return;
	}
	// for some weird reason we get one final drag event with clientX and clientY == 0, which messes up panning, so abort if this is the case:
	if (event.clientX == 0 && event.clientY == 0) {
		return;
	}
	event.preventDefault();

	// tricky: we need to calculate absolute pixel delta offset into relative translate % .
	var md = {}; // mousedata
	if (event) {
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * drag.scale;
		md.el_width  = md.el_width_original  * drag.scale;
	}
	// NB: don't use offsetXY, as this changes while the element is moving under the cursor.
	var dx = event.clientX - drag.mousedown.clientX;
	var dy = event.clientY - drag.mousedown.clientY;
	var rel_dx = dx / md.el_width;
	var rel_dy = dy / md.el_height;

	var new_translate_x = 0, new_translate_y = 0;
	new_translate_x = drag.mousedown.translate_x + rel_dx;
	new_translate_y = drag.mousedown.translate_y + rel_dy;

	el.current_translate_x = new_translate_x;
	el.current_translate_y = new_translate_y;

	new_translate_x = (new_translate_x * 100) + '%';
	new_translate_y = (new_translate_y * 100) + '%';
	el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
}



</script>
 <!-- nomovie1 --> 
  
  
  
  
  
   
   


<!-- DRAGABLE 3 chireaqp -->
<!-- Draggable DIV -->
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<div id="mydiv5"  class="js_zoom_and_pan5">
  <div id="mydivheader5">Click Aqui para mover</div>
  <script>
  
  
  
  (function() {
  function touchHandler(e) {
    var touches = e.changedTouches;
    var first = touches[0];
    var type = "";

    switch(e.type) {
      case "touchstart":
        type = "mousedown";
        break;
      case "touchmove":
        type="mousemove";
        break;
      case "touchend":
        type="mouseup";
        break;
      default:
        return;
    }

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);

    first.target.dispatchEvent(simulatedEvent);
    e.preventDefault();
  }

  function init() {
    document.addEventListener("touchstart", touchHandler, true);
    document.addEventListener("touchmove", touchHandler, true);
    document.addEventListener("touchend", touchHandler, true);
    document.addEventListener("touchcancel", touchHandler, true);
  }

  init();
})();


(function($) {
    $.fn.drags = function(opt) {

        opt = $.extend({handle:"",cursor:"move"}, opt);

        if(opt.handle === "") {
            var $el = this;
        } else {
            var $el = this.find(opt.handle);
        }

        return $el.css('cursor', opt.cursor).on("mousedown", function(e) {
            if(opt.handle === "") {
                var $drag = $(this).addClass('draggable');
            } else {
                var $drag = $(this).addClass('active-handle').parent().addClass('draggable');
            }
            var z_idx = $drag.css('z-index'),
                drg_h = $drag.outerHeight(),
                drg_w = $drag.outerWidth(),
                pos_y = $drag.offset().top + drg_h - e.pageY,
                pos_x = $drag.offset().left + drg_w - e.pageX;
            $drag.css('z-index', 1000).parents().on("mousemove", function(e) {
                $('.draggable').offset({
                    top:e.pageY + pos_y - drg_h,
                    left:e.pageX + pos_x - drg_w
                }).on("mouseup", function() {
                    $(this).removeClass('draggable').css('z-index', z_idx);
                });
            });
            e.preventDefault(); // disable selection
        }).on("mouseup", function() {
            if(opt.handle === "") {
                $(this).removeClass('draggable');
            } else {
                $(this).removeClass('active-handle').parent().removeClass('draggable');
            }
        });

    }
})(jQuery);

$('#mydiv5').drags();
  
  

</script>
<style>
#mydiv5 {
  padding: 0px;
		margin: 0px;
		position: fixed;
  
		right: 0px;
		bottom:0px;
		width: 120px;
    height: 230px;
    text-align: center;
    z-index: 9999px;
    font-size: 5px;
}

#mydivheader5 {
  border-radius: 15px;
 padding: 10px;
  cursor: grab;
  
  background-color: #2196F3;
  color: #fff;
  
}
</style>
 <!-- BUSCADOR 3 -->
  <!-- Trigger/Open The Modal -->
	<button id="myBtn5" class="button button5">chireaqp</button>
<!-- The Modal -->
		<div id="myModal5" class="modal5">
<!-- Modal content -->
		<div class="modal5-content">
		<div class="modal5-header">
			<span class="close5">X</span>
	</div>
  <div class="modal5-body">
	<script>
  // Get the modal
var modal5 = document.getElementById('myModal5');
// Get the modal
var modal5 = document.getElementById('myModal5');
// Get the button that opens the modal
var btn5 = document.getElementById("myBtn5");
// Get the <span> element that closes the modal
var span5 = document.getElementsByClassName("close5")[0];
// When the user clicks on the button, open the modal
btn5.onclick = function() {
    modal5.style.display = "block";
	modal5.style.display = "block";
}
// When the user clicks on <span> (x), close the modal
span5.onclick = function() {
    modal5.style.display = "none";
}
// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal5) {
        modal5.style.display = "none";
    }
}
</script>
<body>
 <style>
      #twitch-embed {
        
        margin-right: 20px;
        top:300px;
       border: 0px solid #888;
        width: 180px;
        height: 240px;
        
      }
    </style>

    <div id="twitch5-embed">
<!-- Load the Twitch embed script -->
    <script src="https://embed.twitch.tv/embed/v1.js"></script>
 <!-- Create a Twitch.Embed object that will render within the "twitch-embed" root element. -->
   <script type="text/javascript">
      new Twitch.Embed("twitch5-embed", {
      
        width: "100%",
        height: "100%",
        channel: "elmacarius",
        // Only needed if this page is going to be embedded on other websites
        parent: ["jsfiddle.net", "hdriplatino.com"]
      });
</script>	
    </div>
    </body>
<!-- trovo 3 -->
<body>
<div>
</div>
</body>
</div>
</div>
</div>
<style type="text/css">
body {
	font-family: Arial, Helvetica, sans-serif;
}
t /* The Modal (background) */
.modal5 {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1px; /* Sit on top */
    left: 0px;
    top: 300px;
     margin: 0px; /* 15% from the top and centered */
    border: 0px solid #888;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    
}
/* Modal Content/Box contenido de tiwtch  */
.modal5-content {
	position: fixed;
    background-color: #fefefe;
    margin: 0px; /* 15% from the top and centered */
    padding: 0;
   border: 0px solid #888;
	border-radius: 15px;
    width: 120px; /* Could be more or less, depending on screen size */
	box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 0.4s;
    animation-name: animatebottom;
    animation-duration: 0.4s
}

/* Add Animation */
@-webkit-keyframes animatetop {
    from {top:-300px; opacity:0} 
    to {top:0; opacity:1}
}
@keyframes animatetop {
    from {top:-300px; opacity:0}
    to {top:0; opacity:1}
}
/* The Close Button */
.close5 {
    color: #666;
    float: right;
    font-size: 9px;
    font-weight: bold;
}
.close5:hover, .close5:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}
/* Modal Header */
.modal5-header {
    padding: 2px 16px;
    background-color: #f0f0f0;
	font-size: 22px;
	text-align: center;
    color: black;
}
/* Modal Body */
.modal5-body {padding: 2px 16px;}
.button5 {
top: 300px;
width: 100px;
font-size: 10px;
margin: 0px; /* 15% from the top and centered */
 }
</style>
  </div>
<!-- BUSCADOR 3 -->
      
		

<!--

TODO: lots of code cleanup, closure, scoping, options, config, etc.
      But it is a working prototype so far.

Interface:
- DoubleClick to reset element to original zoom and position.
- Mousewheel to zoom.
- Click and drag to pan element.

Works: 
- zooming in/out by using mousewheel
- panning image so mouse cursor stays focused on the same spot while zooming,
  (using css transform: translate(x%, y%) )
- pan image by dragging, using same system as above so we can both zoom and pan without problems.

See js panel for more details.

TODO: check support for different browser clients.


-->

<a href="js_zoom_and_pan5" class="MagicZoom" data-options="zoomMode: off"><img src=""></a>

<style>
html, body{
	background: #000;
	color: #fff;
	margin: 0;
	padding: 0;
}
container {
	position: absolute;
	top: 10px;
	left: 10px;
	overflow: hidden;
	width: 95%;
	height: 95%;
	background: rgba(255, 0, 255, 0.1);
	border: 1px solid rgba(255, 0, 255, 0.2);
}
.js_zoom_and_pan5 {
	background: rgba(255, 255, 0, 0.1);
	border: 1px solid rgba(255, 255, 0, 0.2);
  
}
.js_zoom_and_pan5:hover {
    
    zoom: 2.3;
}

</style>

<script>


// https://jsfiddle.net/ElMoonLite/fog2vach/

// TODO: lots of code cleanup, closure, scoping, etc.
//
// REQUIREMENTS:
// Can basicly zoom and pan any element, 
// as long as nothing else is adjusting it's css properties for zoom and/or transform.
// Works best if inside an overflow: hidden element. 
// Can get weird behaviour if inside a scrollable element (or even full document scroll).
//
// NOTES, references, etc.:
// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
// https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
// deltaY > 0 = mousewheel down
// To make event.preventDefault() work on wheel event:
// https://stackoverflow.com/questions/44406297/mark-event-as-explicitly-not-passive


// https://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery
function ready(callback) {
	if (document.readyState!='loading') {
		// in case the document is already rendered
		callback();
	} else if (document.addEventListener) {
		// modern browsers
		document.addEventListener('DOMContentLoaded', callback);
	} else {
		// IE <= 8
		document.attachEvent('onreadystatechange', function(){
			if (document.readyState=='complete') {
				callback();
			}
		});
	}
}

ready(function() {
    init();
});

function init() {
	// wheel event for zooming:
	// NB: { passive: false } needed so we can do event.preventDefault() on mousewheel event (to prevent scrolling and zooming at the same time).
	document.body.addEventListener('wheel', function(event) {
		handleWheel(event);
	}, { passive: false } );

	// events below are for panning:
	document.body.addEventListener('dragstart', function(event){
		handleDragStart(event);
	});
	document.body.addEventListener('dragend', function(event){
		stopDrag();
	});
	document.body.addEventListener('drag', function(event){
		handleDrag(event);
	});
//	// This prevents dragging the entire element out of view if it is inside an overflow: hidden container, 
//	// (in which case you can't drag it back into view again).
//	// Except that it does not seem to work... mouseout never fires while dragging?
//	document.body.addEventListener('mouseout', function(event){
//		console.log('mouseout', event);
//		stopDrag();
//	});
	document.body.addEventListener('dblclick', function(event){
		handleDblClick(event);
	});
}

function ElementIsZoomPanTarget(el) {
	//	if (el.tagName !== 'IMG') { return false; }
	return el && el.classList && el.classList.contains && el.classList.contains('js_zoom_and_pan5');
}

function handleDblClick(event) {
	var el = event.target;
	if (ElementIsZoomPanTarget(el) ) {
		event.preventDefault();
		clearSelection();
		resetElement(el);
	}
	// if element has a direct child also reset it.
	// this allows easy resetting of element just outside element in parent element, 
	// which is handy in case it moves out of frame or just for convenience.
	if (el.childNodes && el.childNodes.length) {
		for (var i=0; i<el.childNodes.length; i++) {
			var el2 = el.childNodes[i];
			if (ElementIsZoomPanTarget(el2) ) {
				event.preventDefault();
				clearSelection();
				resetElement(el2);
			}
		}
	}
}
function resetElement(el) {
	stopDrag();
	el.style.zoom = 1;
	el.scale = 1;
	el.style.transform = 'translate(0%, 0%)';
	el.current_translate_x = 0;
	el.current_translate_y = 0;
}
function clearSelection()
{
	if (window.getSelection) {
		window.getSelection().removeAllRanges();
	} else if (document.selection) {
		document.selection.empty();
	}
}



function handleWheel(event) {
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	event.preventDefault();
	if(isDragging()) {
		// prevent zooming while dragging/panning or things get really complicated.
		return;
	}
	zoomElement(el, event, true);
}

function zoomElement(el, event, zoomatcursor) {
	// Also autoscroll so mouse pointer is on the same relative position after zooming.
	// - using parent element scrolling container?
	// - using translateXY ? transform: translate(100px, 200px);
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-box
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
	// DONE! works :), but:
	//
	// TODO: sometimes after a while weird things happen when zooming.
	// I think it has to do with zooming out, the element becoming smaller and then the max scrollwidth/height gets smaller and the parent element also starts scrolling?

	var scale = 1;
	if (el.scale) {
		scale = el.scale;
	}

	var scale_delta;
	if (event.deltaY < 0) {
		scale_delta = 1.25;
	} else {
		scale_delta = 1 / 1.25; // 0.8
	}
	scale *= scale_delta;


	// attempt at zooming in/out on cursor (scrolling so mouse keeps in same original spot)
	var md = {}; // mousedata
	if (zoomatcursor) {
		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX
		// The offsetX read-only property of the MouseEvent interface provides the offset in the X coordinate of the mouse pointer between that event and the padding edge of the target node.
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * scale;
		md.el_width  = md.el_width_original  * scale;
		md.el_mouse_x = event.offsetX;
		md.el_mouse_y = event.offsetY;
		md.el_mouse_relative_x = md.el_mouse_x / md.el_width;
		md.el_mouse_relative_y = md.el_mouse_y / md.el_height;
	}


	if (scale > 1 - 0.01 && scale < 1 + 0.01) {
		// when zooming in and out a few times due to floating point issues you might not end up at 1 again, fix this:
		scale = 1;
	}
//	scale = Math.min(Math.max(0.125, scale), 4);

	// store new current scale on element for next event:
	el.scale = scale;

	// NB: using transform: scale() produces odd behaviour (or does not work at all) with scale < 1. but zoom seems to work just fine.
//	el.style.transform = 'scale(' + scale + ')';
	el.style.zoom = scale;

	if (zoomatcursor) {
		var current_translate_x = 0;
		var current_translate_y = 0;
		var new_translate_x = 0, new_translate_y = 0;
		if (el.current_translate_x) { current_translate_x = el.current_translate_x; }
		if (el.current_translate_y) { current_translate_y = el.current_translate_y; }

//		// with scale_delta = 1.25 or 1/1.25:
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.

//		if (scale_delta > 1) {
//			new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / scale_delta;
//			new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / scale_delta;
//		} else {
//			new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x / scale_delta;
//			new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y / scale_delta;
//		}

		// The above combined:
		new_translate_x = (md.el_mouse_relative_x) * (1.0 - scale_delta) + current_translate_x / scale_delta;
		new_translate_y = (md.el_mouse_relative_y) * (1.0 - scale_delta) + current_translate_y / scale_delta;

		el.current_translate_x = new_translate_x;
		el.current_translate_y = new_translate_y;

//		new_translate_x = (new_translate_x) + 'px';
//		new_translate_y = (new_translate_y) + 'px';
		new_translate_x = (new_translate_x * 100.0) + '%';
		new_translate_y = (new_translate_y * 100.0) + '%';
		el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
	}

}

// additional: Panning: on mouse down drag; also translate target:
// tricky as we get mouse offset in px, but need to adjust translate in % .
var drag = {};
function isDragging() {
	return !!drag.target;
}
function stopDrag() {
	drag.target = null;
}
function handleDragStart(event) {
	if (isDragging()) {
		return;
	}
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	drag.target = el;
	drag.mousedown = {};
	drag.mousedown.clientX = event.clientX;
	drag.mousedown.clientY = event.clientY;
	drag.mousedown.translate_x = el.current_translate_x || 0;
	drag.mousedown.translate_y = el.current_translate_y || 0;
	drag.scale = el.scale || 1;
}
function handleDrag(event){
	var el = event.target;
	if (!drag.target || el !== drag.target) {
		return;
	}
	// for some weird reason we get one final drag event with clientX and clientY == 0, which messes up panning, so abort if this is the case:
	if (event.clientX == 0 && event.clientY == 0) {
		return;
	}
	event.preventDefault();

	// tricky: we need to calculate absolute pixel delta offset into relative translate % .
	var md = {}; // mousedata
	if (event) {
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * drag.scale;
		md.el_width  = md.el_width_original  * drag.scale;
	}
	// NB: don't use offsetXY, as this changes while the element is moving under the cursor.
	var dx = event.clientX - drag.mousedown.clientX;
	var dy = event.clientY - drag.mousedown.clientY;
	var rel_dx = dx / md.el_width;
	var rel_dy = dy / md.el_height;

	var new_translate_x = 0, new_translate_y = 0;
	new_translate_x = drag.mousedown.translate_x + rel_dx;
	new_translate_y = drag.mousedown.translate_y + rel_dy;

	el.current_translate_x = new_translate_x;
	el.current_translate_y = new_translate_y;

	new_translate_x = (new_translate_x * 100) + '%';
	new_translate_y = (new_translate_y * 100) + '%';
	el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
}



</script>


	
  
  
   
   


<!-- DRAGABLE 3 chireaqp -->
<!-- Draggable DIV -->
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<div id="mydiv9"  class="js_zoom_and_pan9">
  <div id="mydivheader9">Click Aqui para mover</div>
  <script>
  
  
  
  (function() {
  function touchHandler(e) {
    var touches = e.changedTouches;
    var first = touches[0];
    var type = "";

    switch(e.type) {
      case "touchstart":
        type = "mousedown";
        break;
      case "touchmove":
        type="mousemove";
        break;
      case "touchend":
        type="mouseup";
        break;
      default:
        return;
    }

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);

    first.target.dispatchEvent(simulatedEvent);
    e.preventDefault();
  }

  function init() {
    document.addEventListener("touchstart", touchHandler, true);
    document.addEventListener("touchmove", touchHandler, true);
    document.addEventListener("touchend", touchHandler, true);
    document.addEventListener("touchcancel", touchHandler, true);
  }

  init();
})();


(function($) {
    $.fn.drags = function(opt) {

        opt = $.extend({handle:"",cursor:"move"}, opt);

        if(opt.handle === "") {
            var $el = this;
        } else {
            var $el = this.find(opt.handle);
        }

        return $el.css('cursor', opt.cursor).on("mousedown", function(e) {
            if(opt.handle === "") {
                var $drag = $(this).addClass('draggable');
            } else {
                var $drag = $(this).addClass('active-handle').parent().addClass('draggable');
            }
            var z_idx = $drag.css('z-index'),
                drg_h = $drag.outerHeight(),
                drg_w = $drag.outerWidth(),
                pos_y = $drag.offset().top + drg_h - e.pageY,
                pos_x = $drag.offset().left + drg_w - e.pageX;
            $drag.css('z-index', 1000).parents().on("mousemove", function(e) {
                $('.draggable').offset({
                    top:e.pageY + pos_y - drg_h,
                    left:e.pageX + pos_x - drg_w
                }).on("mouseup", function() {
                    $(this).removeClass('draggable').css('z-index', z_idx);
                });
            });
            e.preventDefault(); // disable selection
        }).on("mouseup", function() {
            if(opt.handle === "") {
                $(this).removeClass('draggable');
            } else {
                $(this).removeClass('active-handle').parent().removeClass('draggable');
            }
        });

    }
})(jQuery);

$('#mydiv9999').drags();
  
  

</script>
<style>
#mydiv9 {
  padding: 0px;
		margin: 0px;
		position: fixed;
  
		right: 10px;
		bottom:0px;
		width: 120px;
    height: 230px;
    text-align: center;
    z-index: 9999px;
    font-size: 5px;
}

#mydivheader9 {
  border-radius: 15px;
 padding: 10px;
  cursor: grab;
  
  background-color: #2196F3;
  color: #fff;
  
}
</style>
 <!-- BUSCADOR 3 -->
  <!-- Trigger/Open The Modal -->
	<button id="myBtn9" class="button button9">sugarser0</button>
<!-- The Modal -->
		<div id="myModal9" class="modal9">
<!-- Modal content -->
		<div class="modal9-content">
		<div class="modal9-header">
			<span class="close9">X</span>
	</div>
  <div class="modal9-body">
	<script>
  // Get the modal
var modal9 = document.getElementById('myModal9');
// Get the modal
var modal9 = document.getElementById('myModal9');
// Get the button that opens the modal
var btn9 = document.getElementById("myBtn9");
// Get the <span> element that closes the modal
var span9 = document.getElementsByClassName("close9")[0];
// When the user clicks on the button, open the modal
btn9.onclick = function() {
    modal9.style.display = "block";
	modal9.style.display = "block";
}
// When the user clicks on <span> (x), close the modal
span9.onclick = function() {
    modal9.style.display = "none";
}
// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal9) {
        modal9.style.display = "none";
    }
}
</script>
<body>
 <style>
      #twitch-embed {
        
        margin-right: 20px;
        top:300px;
       border: 0px solid #888;
        width: 180px;
        height: 240px;
        
      }
    </style>

    <div id="twitch9-embed">
<!-- Load the Twitch embed script -->
    <script src="https://embed.twitch.tv/embed/v1.js"></script>
 <!-- Create a Twitch.Embed object that will render within the "twitch-embed" root element. -->
   <script type="text/javascript">
      new Twitch.Embed("twitch9-embed", {
      
        width: "100%",
        height: "100%",
        channel: "sugarser0",
        // Only needed if this page is going to be embedded on other websites
        parent: ["jsfiddle.net", "hdriplatino.com"]
      });
</script>	
    </div>
    </body>
<!-- trovo 3 -->
<body>
<div>
</div>
</body>
</div>
</div>
</div>
<style type="text/css">
body {
	font-family: Arial, Helvetica, sans-serif;
}
t /* The Modal (background) */
.modal9 {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1px; /* Sit on top */
    left: 0px;
    top: 300px;
     margin: 0px; /* 15% from the top and centered */
    border: 0px solid #888;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    
}
/* Modal Content/Box contenido de tiwtch  */
.modal9-content {
	position: fixed;
    background-color: #fefefe;
    margin: 0px; /* 15% from the top and centered */
    padding: 0;
   border: 0px solid #888;
	border-radius: 15px;
    width: 120px; /* Could be more or less, depending on screen size */
	box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 0.4s;
    animation-name: animatebottom;
    animation-duration: 0.4s
}

/* Add Animation */
@-webkit-keyframes animatetop {
    from {top:-300px; opacity:0} 
    to {top:0; opacity:1}
}
@keyframes animatetop {
    from {top:-300px; opacity:0}
    to {top:0; opacity:1}
}
/* The Close Button */
.close9 {
    color: #666;
    float: right;
    font-size: 9px;
    font-weight: bold;
}
.close9:hover, .close5:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}
/* Modal Header */
.modal9-header {
    padding: 2px 16px;
    background-color: #f0f0f0;
	font-size: 22px;
	text-align: center;
    color: black;
}
/* Modal Body */
.modal9-body {padding: 2px 16px;}
.button5 {
top: 300px;
width: 100px;
font-size: 10px;
margin: 0px; /* 15% from the top and centered */
 }
</style>
  </div>
<!-- BUSCADOR 3 -->
      
		

<!--

TODO: lots of code cleanup, closure, scoping, options, config, etc.
      But it is a working prototype so far.

Interface:
- DoubleClick to reset element to original zoom and position.
- Mousewheel to zoom.
- Click and drag to pan element.

Works: 
- zooming in/out by using mousewheel
- panning image so mouse cursor stays focused on the same spot while zooming,
  (using css transform: translate(x%, y%) )
- pan image by dragging, using same system as above so we can both zoom and pan without problems.

See js panel for more details.

TODO: check support for different browser clients.


-->

<a href="js_zoom_and_pan9" class="MagicZoom" data-options="zoomMode: off"><img src=""></a>

<style>
html, body{
	background: #000;
	color: #fff;
	margin: 0;
	padding: 0;
}
container {
	position: absolute;
	top: 10px;
	left: 10px;
	overflow: hidden;
	width: 95%;
	height: 95%;
	background: rgba(255, 0, 255, 0.1);
	border: 1px solid rgba(255, 0, 255, 0.2);
}
.js_zoom_and_pan9 {
	background: rgba(255, 255, 0, 0.1);
	border: 1px solid rgba(255, 255, 0, 0.2);
  
}
.js_zoom_and_pan9:hover {
    
    zoom: 2.3;
}

</style>

<script>


// https://jsfiddle.net/ElMoonLite/fog2vach/

// TODO: lots of code cleanup, closure, scoping, etc.
//
// REQUIREMENTS:
// Can basicly zoom and pan any element, 
// as long as nothing else is adjusting it's css properties for zoom and/or transform.
// Works best if inside an overflow: hidden element. 
// Can get weird behaviour if inside a scrollable element (or even full document scroll).
//
// NOTES, references, etc.:
// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
// https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
// deltaY > 0 = mousewheel down
// To make event.preventDefault() work on wheel event:
// https://stackoverflow.com/questions/44406297/mark-event-as-explicitly-not-passive


// https://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery
function ready(callback) {
	if (document.readyState!='loading') {
		// in case the document is already rendered
		callback();
	} else if (document.addEventListener) {
		// modern browsers
		document.addEventListener('DOMContentLoaded', callback);
	} else {
		// IE <= 8
		document.attachEvent('onreadystatechange', function(){
			if (document.readyState=='complete') {
				callback();
			}
		});
	}
}

ready(function() {
    init();
});

function init() {
	// wheel event for zooming:
	// NB: { passive: false } needed so we can do event.preventDefault() on mousewheel event (to prevent scrolling and zooming at the same time).
	document.body.addEventListener('wheel', function(event) {
		handleWheel(event);
	}, { passive: false } );

	// events below are for panning:
	document.body.addEventListener('dragstart', function(event){
		handleDragStart(event);
	});
	document.body.addEventListener('dragend', function(event){
		stopDrag();
	});
	document.body.addEventListener('drag', function(event){
		handleDrag(event);
	});
//	// This prevents dragging the entire element out of view if it is inside an overflow: hidden container, 
//	// (in which case you can't drag it back into view again).
//	// Except that it does not seem to work... mouseout never fires while dragging?
//	document.body.addEventListener('mouseout', function(event){
//		console.log('mouseout', event);
//		stopDrag();
//	});
	document.body.addEventListener('dblclick', function(event){
		handleDblClick(event);
	});
}

function ElementIsZoomPanTarget(el) {
	//	if (el.tagName !== 'IMG') { return false; }
	return el && el.classList && el.classList.contains && el.classList.contains('js_zoom_and_pan9');
}

function handleDblClick(event) {
	var el = event.target;
	if (ElementIsZoomPanTarget(el) ) {
		event.preventDefault();
		clearSelection();
		resetElement(el);
	}
	// if element has a direct child also reset it.
	// this allows easy resetting of element just outside element in parent element, 
	// which is handy in case it moves out of frame or just for convenience.
	if (el.childNodes && el.childNodes.length) {
		for (var i=0; i<el.childNodes.length; i++) {
			var el2 = el.childNodes[i];
			if (ElementIsZoomPanTarget(el2) ) {
				event.preventDefault();
				clearSelection();
				resetElement(el2);
			}
		}
	}
}
function resetElement(el) {
	stopDrag();
	el.style.zoom = 1;
	el.scale = 1;
	el.style.transform = 'translate(0%, 0%)';
	el.current_translate_x = 0;
	el.current_translate_y = 0;
}
function clearSelection()
{
	if (window.getSelection) {
		window.getSelection().removeAllRanges();
	} else if (document.selection) {
		document.selection.empty();
	}
}



function handleWheel(event) {
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	event.preventDefault();
	if(isDragging()) {
		// prevent zooming while dragging/panning or things get really complicated.
		return;
	}
	zoomElement(el, event, true);
}

function zoomElement(el, event, zoomatcursor) {
	// Also autoscroll so mouse pointer is on the same relative position after zooming.
	// - using parent element scrolling container?
	// - using translateXY ? transform: translate(100px, 200px);
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-box
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
	// DONE! works :), but:
	//
	// TODO: sometimes after a while weird things happen when zooming.
	// I think it has to do with zooming out, the element becoming smaller and then the max scrollwidth/height gets smaller and the parent element also starts scrolling?

	var scale = 1;
	if (el.scale) {
		scale = el.scale;
	}

	var scale_delta;
	if (event.deltaY < 0) {
		scale_delta = 1.25;
	} else {
		scale_delta = 1 / 1.25; // 0.8
	}
	scale *= scale_delta;


	// attempt at zooming in/out on cursor (scrolling so mouse keeps in same original spot)
	var md = {}; // mousedata
	if (zoomatcursor) {
		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX
		// The offsetX read-only property of the MouseEvent interface provides the offset in the X coordinate of the mouse pointer between that event and the padding edge of the target node.
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * scale;
		md.el_width  = md.el_width_original  * scale;
		md.el_mouse_x = event.offsetX;
		md.el_mouse_y = event.offsetY;
		md.el_mouse_relative_x = md.el_mouse_x / md.el_width;
		md.el_mouse_relative_y = md.el_mouse_y / md.el_height;
	}


	if (scale > 1 - 0.01 && scale < 1 + 0.01) {
		// when zooming in and out a few times due to floating point issues you might not end up at 1 again, fix this:
		scale = 1;
	}
//	scale = Math.min(Math.max(0.125, scale), 4);

	// store new current scale on element for next event:
	el.scale = scale;

	// NB: using transform: scale() produces odd behaviour (or does not work at all) with scale < 1. but zoom seems to work just fine.
//	el.style.transform = 'scale(' + scale + ')';
	el.style.zoom = scale;

	if (zoomatcursor) {
		var current_translate_x = 0;
		var current_translate_y = 0;
		var new_translate_x = 0, new_translate_y = 0;
		if (el.current_translate_x) { current_translate_x = el.current_translate_x; }
		if (el.current_translate_y) { current_translate_y = el.current_translate_y; }

//		// with scale_delta = 1.25 or 1/1.25:
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.

//		if (scale_delta > 1) {
//			new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / scale_delta;
//			new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / scale_delta;
//		} else {
//			new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x / scale_delta;
//			new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y / scale_delta;
//		}

		// The above combined:
		new_translate_x = (md.el_mouse_relative_x) * (1.0 - scale_delta) + current_translate_x / scale_delta;
		new_translate_y = (md.el_mouse_relative_y) * (1.0 - scale_delta) + current_translate_y / scale_delta;

		el.current_translate_x = new_translate_x;
		el.current_translate_y = new_translate_y;

//		new_translate_x = (new_translate_x) + 'px';
//		new_translate_y = (new_translate_y) + 'px';
		new_translate_x = (new_translate_x * 100.0) + '%';
		new_translate_y = (new_translate_y * 100.0) + '%';
		el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
	}

}

// additional: Panning: on mouse down drag; also translate target:
// tricky as we get mouse offset in px, but need to adjust translate in % .
var drag = {};
function isDragging() {
	return !!drag.target;
}
function stopDrag() {
	drag.target = null;
}
function handleDragStart(event) {
	if (isDragging()) {
		return;
	}
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	drag.target = el;
	drag.mousedown = {};
	drag.mousedown.clientX = event.clientX;
	drag.mousedown.clientY = event.clientY;
	drag.mousedown.translate_x = el.current_translate_x || 0;
	drag.mousedown.translate_y = el.current_translate_y || 0;
	drag.scale = el.scale || 1;
}
function handleDrag(event){
	var el = event.target;
	if (!drag.target || el !== drag.target) {
		return;
	}
	// for some weird reason we get one final drag event with clientX and clientY == 0, which messes up panning, so abort if this is the case:
	if (event.clientX == 0 && event.clientY == 0) {
		return;
	}
	event.preventDefault();

	// tricky: we need to calculate absolute pixel delta offset into relative translate % .
	var md = {}; // mousedata
	if (event) {
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * drag.scale;
		md.el_width  = md.el_width_original  * drag.scale;
	}
	// NB: don't use offsetXY, as this changes while the element is moving under the cursor.
	var dx = event.clientX - drag.mousedown.clientX;
	var dy = event.clientY - drag.mousedown.clientY;
	var rel_dx = dx / md.el_width;
	var rel_dy = dy / md.el_height;

	var new_translate_x = 0, new_translate_y = 0;
	new_translate_x = drag.mousedown.translate_x + rel_dx;
	new_translate_y = drag.mousedown.translate_y + rel_dy;

	el.current_translate_x = new_translate_x;
	el.current_translate_y = new_translate_y;

	new_translate_x = (new_translate_x * 100) + '%';
	new_translate_y = (new_translate_y * 100) + '%';
	el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
}



</script>
  
	

<!-- DRAGABLE 3 -->
<!-- Draggable DIV -->
<!-- Draggable DIV -->
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<div id="mydiv6"  class="js_zoom_and_pan6">
  <div id="mydivheader6">Click Aqui para mover</div>
  <script>
  
  
  
  (function() {
  function touchHandler(e) {
    var touches = e.changedTouches;
    var first = touches[0];
    var type = "";

    switch(e.type) {
      case "touchstart":
        type = "mousedown";
        break;
      case "touchmove":
        type="mousemove";
        break;
      case "touchend":
        type="mouseup";
        break;
      default:
        return;
    }

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0, null);

    first.target.dispatchEvent(simulatedEvent);
    e.preventDefault();
  }

  function init() {
    document.addEventListener("touchstart", touchHandler, true);
    document.addEventListener("touchmove", touchHandler, true);
    document.addEventListener("touchend", touchHandler, true);
    document.addEventListener("touchcancel", touchHandler, true);
  }

  init();
})();


(function($) {
    $.fn.drags = function(opt) {

        opt = $.extend({handle:"",cursor:"move"}, opt);

        if(opt.handle === "") {
            var $el = this;
        } else {
            var $el = this.find(opt.handle);
        }

        return $el.css('cursor', opt.cursor).on("mousedown", function(e) {
            if(opt.handle === "") {
                var $drag = $(this).addClass('draggable');
            } else {
                var $drag = $(this).addClass('active-handle').parent().addClass('draggable');
            }
            var z_idx = $drag.css('z-index'),
                drg_h = $drag.outerHeight(),
                drg_w = $drag.outerWidth(),
                pos_y = $drag.offset().top + drg_h - e.pageY,
                pos_x = $drag.offset().left + drg_w - e.pageX;
            $drag.css('z-index', 1000).parents().on("mousemove", function(e) {
                $('.draggable').offset({
                    top:e.pageY + pos_y - drg_h,
                    left:e.pageX + pos_x - drg_w
                }).on("mouseup", function() {
                    $(this).removeClass('draggable').css('z-index', z_idx);
                });
            });
            e.preventDefault(); // disable selection
        }).on("mouseup", function() {
            if(opt.handle === "") {
                $(this).removeClass('draggable');
            } else {
                $(this).removeClass('active-handle').parent().removeClass('draggable');
            }
        });

    }
})(jQuery);

$('#mydiv666').drags();
  
  

</script>
<style>
#mydiv6 {
  padding: 0px;
		margin: 0px;
		position: fixed;
		left: 0px;
		bottom:-300px;
		width: 400px;
    height: 500px;
    text-align: center;
    z-index: 9999;
}

#mydivheader6 {
  border-radius: 15px;
 padding: 10px;
  cursor: move;
  
  background-color: #2196F3;
  color: #fff;
  
}
</style>
 <!-- BUSCADOR 3 -->
  <!-- Trigger/Open The Modal -->
	<button id="myBtn6" class="button button6">CHATgpt</button>
<!-- The Modal -->
		<div id="myModal6" class="modal6">
<!-- Modal content -->
		<div class="modal6-content">
		<div class="modal6-header">
			<span class="close6">CHATGPT CERRAR X</span>
	</div>
  <div class="modal6-body">
	<script>
  // Get the modal


<!-- tdffsd -->
 // Get the modal
var modal6 = document.getElementById('myModal6');
// Get the modal
var modal6 = document.getElementById('myModal6');
// Get the button that opens the modal
var btn6 = document.getElementById("myBtn6");
// Get the <span> element that closes the modal
var span6 = document.getElementsByClassName("close6")[0];
// When the user clicks on the button, open the modal
btn6.onclick = function() {
    modal6.style.display = "block";
	modal6.style.display = "block";
}
// When the user clicks on <span> (x), close the modal
span6.onclick = function() {
    modal6.style.display = "none";
}
// When the user clicks anywhere outside of the modal, close it
window.onclick = function(event) {
    if (event.target == modal6) {
        modal6.style.display = "none";
    }
}
<!-- tsdsdf -->



</script>
<!-- trovo 3 -->

<iframe src="https://chatgpt-ameth.netlify.app" width="100%" height="100%">

</iframe>

<!-- trovo 3 -->
<body>
<div>
</div>
</body>
</div>
</div>
</div>
<style type="text/css">
body {
	font-family: Arial, Helvetica, sans-serif;
}
t /* The Modal (background) */
.modal6 {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1px; /* Sit on top */
    left: 0px;
    top: 300px;
     margin: 0px; /* 15% from the top and centered */
    border: 0px solid #888;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0,0,0); /* Fallback color */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    
}
/* Modal Content/Box contenido de tiwtch  */
.modal6-content {
	position: fixed;
   margin: 3% auto;
  bottom:0px;
    background-color: #fefefe;
    margin: 0px; /* 15% from the top and centered */
    padding: 0;
   border: 0px solid #888;
	border-radius: 15px;
    width: 400px; /* Could be more or less, depending on screen size */
	box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: animatebottom;
    -webkit-animation-duration: 0.4s;
    animation-name: animatebottom;
    animation-duration: 0.4s
}

/* Add Animation */
@-webkit-keyframes animatetop {
    from {top:-300px; opacity:0} 
    to {top:0; opacity:1}
}
@keyframes animatetop {
    from {top:-300px; opacity:0}
    to {top:0; opacity:1}
}
/* The Close Button */
.close6 {
    color: #666;
    float: right;
    width: 600x;
    font-size: 20px;
    font-weight: bold;
}
.close6:hover, .close6:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}
/* Modal Header */
.modal6-header {
    padding: 2px 16px;
    background-color: #f0f0f0;
	font-size: 22px;
	text-align: center;
    color: black;
}
/* Modal Body */
.modal6-body {padding: 2px 16px;}
.button6 {
top: 300px;
width: 200px;

margin: 10px; /* 15% from the top and centered */
 }
</style>
  </div>
<!-- BUSCADOR 3 -->
<!-- DRAGABLE 3 -->

		

<!--

TODO: lots of code cleanup, closure, scoping, options, config, etc.
      But it is a working prototype so far.

Interface:
- DoubleClick to reset element to original zoom and position.
- Mousewheel to zoom.
- Click and drag to pan element.

Works: 
- zooming in/out by using mousewheel
- panning image so mouse cursor stays focused on the same spot while zooming,
  (using css transform: translate(x%, y%) )
- pan image by dragging, using same system as above so we can both zoom and pan without problems.

See js panel for more details.

TODO: check support for different browser clients.


-->

<a href="js_zoom_and_pan6" class="MagicZoom" data-options="zoomMode: off"><img src=""></a>

<style>
html, body{
	background: #000;
	color: #fff;
	margin: 0;
	padding: 0;
}
container {
	position: absolute;
	top: 10px;
	left: 10px;
	overflow: hidden;
	width: 95%;
	height: 95%;
	background: rgba(255, 0, 255, 0.1);
	border: 1px solid rgba(255, 0, 255, 0.2);
}
.js_zoom_and_pan6 {
	background: rgba(255, 255, 0, 0.1);
	border: 1px solid rgba(255, 255, 0, 0.2);
  
}
.js_zoom_and_pan6:hover {
    
    zoom: 1.8;
}

</style>

<script>


// https://jsfiddle.net/ElMoonLite/fog2vach/

// TODO: lots of code cleanup, closure, scoping, etc.
//
// REQUIREMENTS:
// Can basicly zoom and pan any element, 
// as long as nothing else is adjusting it's css properties for zoom and/or transform.
// Works best if inside an overflow: hidden element. 
// Can get weird behaviour if inside a scrollable element (or even full document scroll).
//
// NOTES, references, etc.:
// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
// https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
// deltaY > 0 = mousewheel down
// To make event.preventDefault() work on wheel event:
// https://stackoverflow.com/questions/44406297/mark-event-as-explicitly-not-passive


// https://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery
function ready(callback) {
	if (document.readyState!='loading') {
		// in case the document is already rendered
		callback();
	} else if (document.addEventListener) {
		// modern browsers
		document.addEventListener('DOMContentLoaded', callback);
	} else {
		// IE <= 8
		document.attachEvent('onreadystatechange', function(){
			if (document.readyState=='complete') {
				callback();
			}
		});
	}
}

ready(function() {
    init();
});

function init() {
	// wheel event for zooming:
	// NB: { passive: false } needed so we can do event.preventDefault() on mousewheel event (to prevent scrolling and zooming at the same time).
	document.body.addEventListener('wheel', function(event) {
		handleWheel(event);
	}, { passive: false } );

	// events below are for panning:
	document.body.addEventListener('dragstart', function(event){
		handleDragStart(event);
	});
	document.body.addEventListener('dragend', function(event){
		stopDrag();
	});
	document.body.addEventListener('drag', function(event){
		handleDrag(event);
	});
//	// This prevents dragging the entire element out of view if it is inside an overflow: hidden container, 
//	// (in which case you can't drag it back into view again).
//	// Except that it does not seem to work... mouseout never fires while dragging?
//	document.body.addEventListener('mouseout', function(event){
//		console.log('mouseout', event);
//		stopDrag();
//	});
	document.body.addEventListener('dblclick', function(event){
		handleDblClick(event);
	});
}

function ElementIsZoomPanTarget(el) {
	//	if (el.tagName !== 'IMG') { return false; }
	return el && el.classList && el.classList.contains && el.classList.contains('js_zoom_and_pan6');
}

function handleDblClick(event) {
	var el = event.target;
	if (ElementIsZoomPanTarget(el) ) {
		event.preventDefault();
		clearSelection();
		resetElement(el);
	}
	// if element has a direct child also reset it.
	// this allows easy resetting of element just outside element in parent element, 
	// which is handy in case it moves out of frame or just for convenience.
	if (el.childNodes && el.childNodes.length) {
		for (var i=0; i<el.childNodes.length; i++) {
			var el2 = el.childNodes[i];
			if (ElementIsZoomPanTarget(el2) ) {
				event.preventDefault();
				clearSelection();
				resetElement(el2);
			}
		}
	}
}
function resetElement(el) {
	stopDrag();
	el.style.zoom = 1;
	el.scale = 1;
	el.style.transform = 'translate(0%, 0%)';
	el.current_translate_x = 0;
	el.current_translate_y = 0;
}
function clearSelection()
{
	if (window.getSelection) {
		window.getSelection().removeAllRanges();
	} else if (document.selection) {
		document.selection.empty();
	}
}



function handleWheel(event) {
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	event.preventDefault();
	if(isDragging()) {
		// prevent zooming while dragging/panning or things get really complicated.
		return;
	}
	zoomElement(el, event, true);
}

function zoomElement(el, event, zoomatcursor) {
	// Also autoscroll so mouse pointer is on the same relative position after zooming.
	// - using parent element scrolling container?
	// - using translateXY ? transform: translate(100px, 200px);
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-box
	//   https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin
	// DONE! works :), but:
	//
	// TODO: sometimes after a while weird things happen when zooming.
	// I think it has to do with zooming out, the element becoming smaller and then the max scrollwidth/height gets smaller and the parent element also starts scrolling?

	var scale = 1;
	if (el.scale) {
		scale = el.scale;
	}

	var scale_delta;
	if (event.deltaY < 0) {
		scale_delta = 1.25;
	} else {
		scale_delta = 1 / 1.25; // 0.8
	}
	scale *= scale_delta;


	// attempt at zooming in/out on cursor (scrolling so mouse keeps in same original spot)
	var md = {}; // mousedata
	if (zoomatcursor) {
		// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX
		// The offsetX read-only property of the MouseEvent interface provides the offset in the X coordinate of the mouse pointer between that event and the padding edge of the target node.
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * scale;
		md.el_width  = md.el_width_original  * scale;
		md.el_mouse_x = event.offsetX;
		md.el_mouse_y = event.offsetY;
		md.el_mouse_relative_x = md.el_mouse_x / md.el_width;
		md.el_mouse_relative_y = md.el_mouse_y / md.el_height;
	}


	if (scale > 1 - 0.01 && scale < 1 + 0.01) {
		// when zooming in and out a few times due to floating point issues you might not end up at 1 again, fix this:
		scale = 1;
	}
//	scale = Math.min(Math.max(0.125, scale), 4);

	// store new current scale on element for next event:
	el.scale = scale;

	// NB: using transform: scale() produces odd behaviour (or does not work at all) with scale < 1. but zoom seems to work just fine.
//	el.style.transform = 'scale(' + scale + ')';
	el.style.zoom = scale;

	if (zoomatcursor) {
		var current_translate_x = 0;
		var current_translate_y = 0;
		var new_translate_x = 0, new_translate_y = 0;
		if (el.current_translate_x) { current_translate_x = el.current_translate_x; }
		if (el.current_translate_y) { current_translate_y = el.current_translate_y; }

//		// with scale_delta = 1.25 or 1/1.25:
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 ; // this works CORRECT but only for the FIRST zoom IN.
//		new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / 1.25; // this works CORRECT for ALL CONCURRENT zoom IN.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2; // this works CORRECT but only for the FIRST zoom OUT.
//		new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.
//		new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y * 1.25; // this works CORRECT for ALL CONCURRENT zoom OUT.

//		if (scale_delta > 1) {
//			new_translate_x = - (md.el_mouse_relative_x) * 0.25 + current_translate_x / scale_delta;
//			new_translate_y = - (md.el_mouse_relative_y) * 0.25 + current_translate_y / scale_delta;
//		} else {
//			new_translate_x = + (md.el_mouse_relative_x) * 0.2 + current_translate_x / scale_delta;
//			new_translate_y = + (md.el_mouse_relative_y) * 0.2 + current_translate_y / scale_delta;
//		}

		// The above combined:
		new_translate_x = (md.el_mouse_relative_x) * (1.0 - scale_delta) + current_translate_x / scale_delta;
		new_translate_y = (md.el_mouse_relative_y) * (1.0 - scale_delta) + current_translate_y / scale_delta;

		el.current_translate_x = new_translate_x;
		el.current_translate_y = new_translate_y;

//		new_translate_x = (new_translate_x) + 'px';
//		new_translate_y = (new_translate_y) + 'px';
		new_translate_x = (new_translate_x * 100.0) + '%';
		new_translate_y = (new_translate_y * 100.0) + '%';
		el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
	}

}

// additional: Panning: on mouse down drag; also translate target:
// tricky as we get mouse offset in px, but need to adjust translate in % .
var drag = {};
function isDragging() {
	return !!drag.target;
}
function stopDrag() {
	drag.target = null;
}
function handleDragStart(event) {
	if (isDragging()) {
		return;
	}
	var el = event.target;
	if (!ElementIsZoomPanTarget(el) ) {
		return;
	}
	drag.target = el;
	drag.mousedown = {};
	drag.mousedown.clientX = event.clientX;
	drag.mousedown.clientY = event.clientY;
	drag.mousedown.translate_x = el.current_translate_x || 0;
	drag.mousedown.translate_y = el.current_translate_y || 0;
	drag.scale = el.scale || 1;
}
function handleDrag(event){
	var el = event.target;
	if (!drag.target || el !== drag.target) {
		return;
	}
	// for some weird reason we get one final drag event with clientX and clientY == 0, which messes up panning, so abort if this is the case:
	if (event.clientX == 0 && event.clientY == 0) {
		return;
	}
	event.preventDefault();

	// tricky: we need to calculate absolute pixel delta offset into relative translate % .
	var md = {}; // mousedata
	if (event) {
		md.el_height_original = el.height || el.scrollHeight;
		md.el_width_original  = el.width  || el.scrollWidth;
		// NB: above width and height is correct for zoom scale == 1, but otherwise needs correcting for scale, see below:
		md.el_height = md.el_height_original * drag.scale;
		md.el_width  = md.el_width_original  * drag.scale;
	}
	// NB: don't use offsetXY, as this changes while the element is moving under the cursor.
	var dx = event.clientX - drag.mousedown.clientX;
	var dy = event.clientY - drag.mousedown.clientY;
	var rel_dx = dx / md.el_width;
	var rel_dy = dy / md.el_height;

	var new_translate_x = 0, new_translate_y = 0;
	new_translate_x = drag.mousedown.translate_x + rel_dx;
	new_translate_y = drag.mousedown.translate_y + rel_dy;

	el.current_translate_x = new_translate_x;
	el.current_translate_y = new_translate_y;

	new_translate_x = (new_translate_x * 100) + '%';
	new_translate_y = (new_translate_y * 100) + '%';
	el.style.transform = 'translate(' + new_translate_x + ', ' + new_translate_y + ')';
}



</script>









  </div>
</html>
